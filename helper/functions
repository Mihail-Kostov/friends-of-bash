#!/bin/bash

# ------------
# install method
#
# @author  Björn Hempel <bjoern@hempel.li>
# @version 1.0 (2017-05-21)
# ------------
install()
{
    local       pathRoot="$1"
    local  gitRepository="$2"
    local nameRepository=""

    local ROOT_UID=0

    if [ "$gitRepository" == "" ]; then
        eval "declare -A repositoryValues="$(getRepositoryValues "$pathRoot")
        [ $? -gt 0 ] && (>&2 echo "→ abort") && exit

         gitRepository="${repositoryValues[git]}"
        nameRepository="${repositoryValues[name]}"
    else
        nameRepository=$(getRepositoryNameFromGivenRepository "$gitRepository")
        [ $? -gt 0 ] && (>&2 echo "→ abort") && exit
    fi

    # the global mode needs root credentials
    if [ "$UID" -ne "$ROOT_UID" ]; then
        echo "You need root credentials to install that script into \"$TARGET_FOLDER\"."
        exit 1
    fi

    # get the executive user
    user=$SUDO_USER
    group=$(id -g -n $user)

    # calculate git target paths
    installFolder="$TARGET_FOLDER/$nameRepository"
    installSource="$installFolder/install"

    # install this project to install folder
    if [ ! -d "$installFolder" ]; then
        # create install folder
        mkdir -p "$installFolder"
        chown $user:$group "$installFolder"
        sudo -u $user SSH_AUTH_SOCK=$SSH_AUTH_SOCK git clone "$gitRepository" "$installFolder"

        echo "git repository \"$gitRepository\" successfully installed into \"$installFolder\"."
    else
        echo "The target install folder \"$installFolder\" already exists → skip.." && return 1
    fi

    # check for install file, execute it and exit function
    if [ -f "$installSource" ] && [ -x "$installSource" ]; then
        $installSource
        return $?
    fi

    # check for install folder, install symlinks and exit function
    if [ -d "$installSource" ]; then
        for installFile in $(ls "$installSource"); do
            sourceScript=$(readlink -f "$installSource/$installFile")
            targetScript="$EXECUTIVE_FOLDER/$installFile"

            # delete true file
            if [ ! -L "$targetScript" ] && [ -f "$targetScript" ]; then
                rm "$targetScript"
            fi

            # delete symlink with wrong target
            if [ -L "$targetScript" ]; then
                targetSymlinkPath=$(readlink -f "$targetScript")

                if [ "$targetSymlinkPath" != "$sourceScript" ]; then
                    echo "target from symlink \"$targetSymlinkPath\" is wrong (\"$sourceScript\") → delete this symlink"
                    rm "$sourceScript"
                fi
            fi

            # add symlink if the link doesn't exist
            if [ ! -L "$targetScript" ]; then
                echo "create symlink \"$targetScript\"."
                ln -s "$sourceScript" "$targetScript"
            else
                echo "$targetScript already exists → skip.."
            fi
        done
        return 0
    fi

}

# ------------
# update method
#
# @author  Björn Hempel <bjoern@hempel.li>
# @version 1.0 (2017-05-21)
# ------------
update()
{
    local pathRoot="$1"
    local     name="$2"

    local friendsOfBashCollectionPoint=$(dirname "$pathRoot")

    if [ "${name,,}" == "all" ]; then
        for nameRepository in $(ls "$friendsOfBashCollectionPoint"); do
            local directoryRepository="$friendsOfBashCollectionPoint/$nameRepository"

            if [ ! -d "$directoryRepository/.git" ]; then
                continue;
            fi

            doUpdate "$pathRoot" "$nameRepository"
        done
    else
        doUpdate "$pathRoot" "$name"
    fi
}

# ------------
# do update method
#
# @author  Björn Hempel <bjoern@hempel.li>
# @version 1.0 (2017-06-05)
# ------------
doUpdate()
{
    local pathRoot="$1"
    local name="$2"   

    local friendsOfBashCollectionPoint=$(dirname "$pathRoot")

    if [ "$name" != "" ]; then
        pathRoot="$friendsOfBashCollectionPoint/$name"

        if [ ! -d "$pathRoot/.git" ]; then
            echo "The path \"$pathRoot\" is not a repository path. Abort." && exit
        fi
    fi

    eval "declare -A repositoryValues="$(getRepositoryValues "$pathRoot")
    [ $? -gt 0 ] && (>&2 echo "→ abort") && exit

    local gitRepository="${repositoryValues[git]}"
    local nameRepository="${repositoryValues[name]}"

    local localHash=$(getCurrentChangesetFromGivenPath "$pathRoot")
    local remoteHash=$(getLastChangesetFromGivenRepository "$gitRepository")

    local localVersion=$(getCurrentTagFromGivenPath "$pathRoot")
    local remoteVersion=$(getLastTagByGivenRepository "$gitRepository")

    # no update is available
    if [ "$localHash" == "$remoteHash" ] && [ "$localVersion" == "$remoteVersion" ]; then
        echo "Your \"$pathRoot\" version is up to date. Nothing to do here."
        return 0
    fi

    while true; do
        read -n 1 -p "Do you really want to update the current version \"$localVersion\" from \"$pathRoot\" to \"$remoteVersion\"? Type (y)es or (no): " yn
        case $yn in
            # yes
            [Yy]*)
                break
                ;;
            # no
            [Nn]*)
                echo
                echo "The update was cancelled by user."
                return 1
                ;;
            # escape
            $'\e')
                echo
                echo "The update was cancelled by user."
                return 1
                ;;
            # other character
            *)
                echo
                ;;
        esac
    done

    local workingTreeParameter=$(getWorkingTreeParameter "$pathRoot")

    echo
    git $workingTreeParameter pull
}

# ------------
# status method
#
# @author  Björn Hempel <bjoern@hempel.li>
# @version 1.0 (2017-05-21)
# ------------
status()
{
    local pathRoot="$1"
    local     name="$2"
    
    local friendsOfBashCollectionPoint=$(dirname "$pathRoot")
    
    if [ "${name,,}" == "all" ]; then
        for nameRepository in $(ls "$friendsOfBashCollectionPoint"); do
            local directoryRepository="$friendsOfBashCollectionPoint/$nameRepository"
            
            if [ ! -d "$directoryRepository/.git" ]; then
                continue;
            fi
            
            doStatus "$pathRoot" "$nameRepository"
        done
    else
        doStatus "$pathRoot" "$name"
    fi
}

# ------------
# do status method
#
# @author  Björn Hempel <bjoern@hempel.li>
# @version 1.0 (2017-06-05)
# ------------
doStatus()
{
    local pathRoot="$1"
    local name="$2"

    local friendsOfBashCollectionPoint=$(dirname "$pathRoot")

    if [ "$name" != "" ]; then
        pathRoot="$friendsOfBashCollectionPoint/$name"

        if [ ! -d "$pathRoot/.git" ]; then
            echo "The path \"$pathRoot\" is not a repository path. Abort." && exit
        fi
    fi

    eval "declare -A repositoryValues="$(getRepositoryValues "$pathRoot")
    [ $? -gt 0 ] && (>&2 echo "→ abort") && exit

    local gitRepository="${repositoryValues[git]}"
    local nameRepository="${repositoryValues[name]}"

    local localHash=$(getCurrentChangesetFromGivenPath "$pathRoot")
    local remoteHash=$(getLastChangesetFromGivenRepository "$gitRepository")

    local localVersion=$(getCurrentTagFromGivenPath "$pathRoot")
    local remoteVersion=$(getLastTagByGivenRepository "$gitRepository")

    echo
    echo "$nameRepository"
    printf "%${#nameRepository}s" |tr " " "-"
    echo
    echo
    echo "Currently installed version:   $localVersion"
    echo "Available version:             $remoteVersion"
    echo
    echo "Currently installed changeset: $localHash"
    echo "Available changeset:           $remoteHash"
    echo

    if [ "$localHash" == "$remoteHash" ] && [ "$localVersion" == "$remoteVersion" ]; then
        echo "Your \"$pathRoot\" version is up to date. Nothing to do here."
        echo
    else
        echo "Your \"$pathRoot\" version is not up to date. Please update with:"
        echo "user\$ $0 update $nameRepository"
        echo
    fi
}

# ------------
# list method
#
# @author  Björn Hempel <bjoern@hempel.li>
# @version 1.0 (2017-05-30)
# ------------
list()
{
    local pathRoot="$1"

    local friendsOfBashCollectionPoint=$(dirname "$pathRoot")

    for nameRepository in $(ls "$friendsOfBashCollectionPoint"); do
        directoryRepository="$friendsOfBashCollectionPoint/$nameRepository"

        if [ ! -d "$directoryRepository/.git" ]; then
            continue;
        fi

        local repositoryVersion=$(getRepositoryVersion "$directoryRepository")

        echo "$nameRepository - $repositoryVersion"
    done
}

# ------------
# version method
#
# @author  Björn Hempel <bjoern@hempel.li>
# @version 1.0 (2017-06-04)
# ------------
version()
{
    local pathRoot="$1"
    local name="$2"

    local friendsOfBashCollectionPoint=$(dirname "$pathRoot")

    if [ "$name" != "" ]; then
        pathRoot="$friendsOfBashCollectionPoint/$name"

        if [ ! -d "$pathRoot/.git" ]; then
            echo "The path \"$pathRoot\" is not a repository path. Abort." && exit
        fi
    fi

    local version=$(getRepositoryVersion "$pathRoot")

    echo "$version"
}



# ------------
# updateAvailable method
#
# @author  Björn Hempel <bjoern@hempel.li>
# @version 1.0 (2017-05-21)
# ------------
updateAvailable()
{
    local pathRoot="$1"
    local     name="$2"

    local friendsOfBashCollectionPoint=$(dirname "$pathRoot")

    if [ "${name,,}" == "all" ]; then
        for nameRepository in $(ls "$friendsOfBashCollectionPoint"); do
            local directoryRepository="$friendsOfBashCollectionPoint/$nameRepository"

            if [ ! -d "$directoryRepository/.git" ]; then
                continue;
            fi

            doUpdateAvailable "$pathRoot" "$nameRepository" true
        done
    else
        doUpdateAvailable "$pathRoot" "$name" false
    fi
}

# ------------
# do updateAvailable method
#
# @author  Björn Hempel <bjoern@hempel.li>
# @version 1.0 (2017-06-05)
# ------------
doUpdateAvailable()
{
    local pathRoot="$1"
    local name="$2"
    local showAppName=${3:-false}

    local friendsOfBashCollectionPoint=$(dirname "$pathRoot")

    if [ "$name" != "" ]; then
        pathRoot="$friendsOfBashCollectionPoint/$name"

        if [ ! -d "$pathRoot/.git" ]; then
            echo "The path \"$pathRoot\" is not a repository path. Abort." && exit
        fi
    fi

    eval "declare -A repositoryValues="$(getRepositoryValues "$pathRoot")
    [ $? -gt 0 ] && (>&2 echo "→ abort") && exit

    local gitRepository="${repositoryValues[git]}"
    local nameRepository="${repositoryValues[name]}"

    local  localHash=$(getCurrentChangesetFromGivenPath "$pathRoot")
    local remoteHash=$(getLastRemoteChangesetFromGivenPath "$pathRoot")

    if $showAppName; then
        echo -n "$name: "
    fi

    if [ "$localHash" == "$remoteHash" ]; then
        echo "0"
    else
        echo "1"
    fi
}

# ------------
# updateVersion method
#
# @author  Björn Hempel <bjoern@hempel.li>
# @version 1.0 (2017-06-06)
# ------------
updateVersion()
{
    local pathRoot="$1"
    local name="$2"

    local friendsOfBashCollectionPoint=$(dirname "$pathRoot")

    if [ "$name" != "" ]; then
        pathRoot="$friendsOfBashCollectionPoint/$name"

        if [ ! -d "$pathRoot/.git" ]; then
            echo "The path \"$pathRoot\" is not a repository path. Abort." && exit
        fi
    else
        name="friends-of-bash"
    fi

    currentTag=$(getCurrentTagFromGivenPath "$pathRoot")
       nextTag=$(getNextTagFromGivenPath "$pathRoot")

    echo "name:      $name"
    echo "directory: $pathRoot"
    echo

    while true; do
        read -n 1 -p "This will set the current version number $currentTag to $nextTag. Do you want to continue? Type (y)es or (no): " yn
        case $yn in
            # yes
            [Yy]*)
                break
                ;;
            # no
            [Nn]*)
                echo
                echo "The command was cancelled by user."
                exit
                ;;
            # escape
            $'\e')
                echo
                echo "The command was cancelled by user."
                exit
                ;;
            # other character
            *)
                echo
                ;;
        esac
    done

    local workingTreeParameter=$(getWorkingTreeParameter "$pathRoot")

    echo
    git $workingTreeParameter tag -a $nextTag -m "version $nextTag"
    git $workingTreeParameter push origin $nextTag
    echo "Done!"
}

# ------------
# Shows the version number of this library.
#
# @author  Björn Hempel <bjoern@hempel.li>
# @version 1.0 (2017-05-21)
# ------------
showVersion()
{
    getRepositoryVersion "$pathRoot"
}

