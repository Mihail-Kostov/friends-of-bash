#!/bin/bash

# EXAMPLE:
# --------
#
# OUTPUT_CONTENT_TYPE='json' # or log
#
# setOutputContentType "$OUTPUT_CONTENT_TYPE"
#
# outputContent "ports"          "caption" "Die Beschreibung für den Port Bereich."
# outputContent "ports.80"       "success" "Port 80 ist offen."
# outputContent "ports.443"      "success" "Port 443 ist offen."
# outputContent "ports.111"      "failed"  "Port 111 ist geöffnet."
# outputContent "status"         "caption" "Status Code Beschreibung."
# outputContent "status.typo3"   "success" "Der Typo3 Pfad Test war erfolgreich."
# outputContent "ssl.nonwww"     "success" "The certificate is valid"
# outputContent "ssl.www"        "success" "The certificate is valid"
# outputContent "ssl.www.check2" "success" "The certificate 2 is valid"
# outputContent "ssl.www.check3" "success" "The certificate 3 is valid"
# outputFinish
#

# some vars
currentNamespacePath=""
lastOpenNr=-1
outputType="json"
availableOutputTypes=(json log)

# ------------
# Output content type setter.
#
# @author  Björn Hempel <bjoern@hempel.li>
# @version 1.0 (2017-04-10)
# ------------
setOutputContentType()
{
    local type="$1"

    for availableOutputType in "${availableOutputTypes[@]}"; do
        if [ "$availableOutputType" == "$type" ]; then
            outputType="$type"
            return 0
        fi
    done

    echo "Unknown given type \"$type\"."
    exit
}

# ------------
# Output content switch
#
# @author  Björn Hempel <bjoern@hempel.li>
# @version 1.0 (2017-04-10)
# ------------
outputContent()
{
    case "${outputType^^}" in
        JSON)
            _outputContentJson "$1" "$2" "$3" "$4" "$5"
            ;;

        LOG)
            _outputContentLog "$1" "$2" "$3" "$4" "$5"
            ;;

        *)
            echo "Unknown given type \"${outputType^^}\"."
            ;;
    esac
}

# ------------
# Output content function: log
#
# @author  Björn Hempel <bjoern@hempel.li>
# @version 1.0 (2017-04-10)
# ------------
_outputContentLog()
{
    local      namespacePath="$1"
    local             status="${2^^}"
    local            logText="$3"
    local              debug=${4:-false}
    local              ident=${5:-4}
    local            showLog=${6:-false}
    local               date=`date "+%Y-%m-%d %H:%M:%S"`
    local      numberOfLines=$(echo -e "$logText" | wc -l)
    local multilineSignFirst='┏━  '
    local      multilineSign='┃   '
    local  multilineSignLast='┗━  '
    local             spacer=''

    if [ "$status" == "" ]; then
        return 0
    fi

    # disabled output
    if $showLog; then
        return 0
    fi

    case "$status" in
        SUCCESS)
            status="$COLOR_GREEN$status\033[0m"
            ;;
        PASSED)
            status="\033[1;32m"$status"\033[0m"
            spacer=' '
            ;;
        WARNING)
            status="\033[1;33m\033[5m"$status"\033[0m"
            ;;
        ERROR)
            status="\033[1;31m\033[5m"$status"\033[0m"
            spacer='  '
            ;;
        FAILED)
            status="\033[1;31m\033[5m"$status"\033[0m"
            spacer=' '
            ;;
        INFO)
            status="\033[1;36m"$status"\033[0m"
            spacer='   '
            ;;
        REMOTE)
            status="\033[1;35m"$status"\033[0m"
            spacer=' '
            ;;
        HEADER)
            status="\033[1;34m"$status"\033[0m"
            logText=${logText^^}
            spacer=' '
            ;;
        CAPTION)
            status="\033[1;34m"$status"\033[0m"
            logText=${logText^^}
            ;;
    esac

    # check multiline && replace line breaks
    if [ "$numberOfLines" -gt 1 ]; then
        logText="$multilineSignFirst$logText"
        logText=$(echo -en "$logText" | sed ":a;N;\$!ba;s/\\n/\\n                                $multilineSign/g")
        logText=$(echo -en "$logText" | sed '$s/┃ /┗━/g')
    fi

    echo -e "[$date] [$status]$spacer $logText"
}

# ------------
# Output content function: json
#
# @author  Björn Hempel <bjoern@hempel.li>
# @version 1.0 (2017-04-10)
# ------------
_outputContentJson()
{
    local namespacePath="root.$1"
    local status="$2"
    local description="$3"
    local debug=${4:-false}
    local ident=${5:-4}

    IFS='.' read -r -a namespaceArray        <<< "$namespacePath"
    IFS='.' read -r -a currentNamespaceArray <<< "$currentNamespacePath"

    local uniquePath=""
    local unique=true

    if $debug; then
        printf "1) current:     %-40s %4s\n" "\"$currentNamespacePath\"" "(${#currentNamespaceArray[@]})"
    fi

    for namespaceName in "${currentNamespaceArray[@]}"; do
        [ "$uniquePath" == "" ] && local newUniquePath="$namespaceName" || local newUniquePath="$uniquePath.$namespaceName"

        if $unique; then
            if [[ "$namespacePath" =~ ^$newUniquePath ]] ; then
                uniquePath="$newUniquePath"
            else
                unique=false
            fi
        fi
    done

    if $debug; then
        printf "2) wanted:      %-40s %4s\n" "\"$namespacePath\"" "(${#namespaceArray[@]})"
    fi

    IFS='.' read -r -a uniqueArray <<< "$uniquePath"

    if $debug; then
        printf "3) unique path: %-40s %4s\n" "\"$uniquePath\"" "(${#uniqueArray[@]})"
    fi

    local closeNamespacePath=$(echo $currentNamespacePath | sed -e "s/^${uniquePath}[\.]\?//g" )
    local  openNamespacePath=$(echo $namespacePath        | sed -e "s/^${uniquePath}[\.]\?//g" )

    IFS='.' read -r -a closeNamespaceArray <<< "$closeNamespacePath"
    IFS='.' read -r -a  openNamespaceArray <<< "$openNamespacePath"

    local closeFromNumber="${#currentNamespaceArray[@]}"
    local closeToNumber=$((closeFromNumber - ${#closeNamespaceArray[@]}))
    local closeSum="${#closeNamespaceArray[@]}"
    local closeString=''

    if [ $closeFromNumber -gt $closeToNumber ]; then
        for ((i=$closeFromNumber; i>$closeToNumber; i--)); do
            [ "$closeString" != '' ] && closeString+=', '
            closeString+=$i
        done
    else
        closeString='---'
    fi

    if $debug; then
        printf "4) todo close:  %-40s %4s %s\n" "\"$closeNamespacePath\"" "(${#closeNamespaceArray[@]})" "($closeFromNumber -> $closeToNumber | $closeString)"
    fi

    local openFromNumber="${#uniqueArray[@]}"
    local openToNumber=$((openFromNumber + ${#openNamespaceArray[@]}))
    local openSum="${#openNamespaceArray[@]}"
    local openString=''

    if [ $openToNumber -gt $openFromNumber ]; then
        for ((i=$((openFromNumber+1)); i<=$openToNumber; i++)); do
            [ "$openString" != '' ] && openString+=', '
            openString+=$i
        done
    else
        openString='---'
    fi

    if $debug; then
        printf "5) todo open:   %-40s %4s %s\n" "\"$openNamespacePath\""  "(${#openNamespaceArray[@]})"  "($openFromNumber -> $openToNumber | $openString)"
    fi

    

    # print close tags
    if [ $closeFromNumber -gt $closeToNumber ]; then
        for ((i=$((closeFromNumber - 1)); i>$((closeToNumber - 1)); i--)); do
            if [ $lastOpenNr -gt 0 ]; then
                echo
            fi

            outputIdent $((2 * i + 0)) "}" false

            if [ $i -eq $closeToNumber ]; then
                if [ $i -ne $openFromNumber ] && [ $openToNumber -gt $openFromNumber ]; then
                    echo && outputIdent $((2 * i - 1)) "}" false
                fi
            else
                echo && outputIdent $((2 * i - 1)) "}" false
            fi
        done
    fi

    # print open tags 
    if [ $openToNumber -gt $openFromNumber ]; then
        for ((i=$openFromNumber; i<=$((openToNumber - 1)); i++)); do
            if [ $i -gt 0 ]; then
                if [ $closeToNumber -eq $openFromNumber ] && [ $closeFromNumber -gt $closeToNumber ] && [ $i -eq $openFromNumber ]; then
                    echo ","
                    outputIdent $((2 * i + 0)) "${namespaceArray[i]}: {"
                else
                    echo ","
                    outputIdent $((2 * i - 1)) "data: {"
                    outputIdent $((2 * i + 0)) "${namespaceArray[i]}: {"
                fi
            else
                outputIdent $((2 * i + 0)) "{"
            fi

            local namepath=""
            for ((j=0; j<${#namespaceArray[@]}; j++)); do
                [ $j -gt $i ] && continue
                [ "$namepath" != "" ] && namepath+="."
                namepath+="${namespaceArray[$j]}"
            done

            outputIdent $((2 * i + 1)) "path: \"$namepath\"" false

            # if last opened area: print status and description if given
            if [ $i -eq $((openToNumber - 1)) ]; then
                [ "$status" != "" ] && \
                [ "$status" != "caption" ] && \
                echo "," && \
                outputIdent $((2 * i + 1)) "status: \"$status\"" false

                [ "$description" != "" ] && \
                echo "," && \
                outputIdent $((2 * i + 1)) "description: \"$description\"" false
            fi

            lastOpenNr=$i
        done
    else
        if [ $closeFromNumber -gt $closeToNumber ]; then
            echo ""
        fi
    fi

    currentNamespacePath="$namespacePath"

    if $debug; then
        echo
    fi
}

# ------------
# Output content function: closer
#
# @author  Björn Hempel <bjoern@hempel.li>
# @version 1.0 (2017-04-10)
# ------------
outputFinish()
{
    outputContent "" "" ""
    outputIdent 1 "}"
    outputIdent 0 "}"
}

# ------------
# Output content helper function: outputIdent
#
# @author  Björn Hempel <bjoern@hempel.li>
# @version 1.0 (2017-04-10)
# ------------
outputIdent()
{
    local identNr=${1:-0}
    local text="${2:-}"
    local linebreak=${3:-true}
    local identChar=${4:- }
    local ident=4

    case $outputType in
        json)
            if [ $identNr -gt 0 ]; then
                printf "%-$((identNr * $ident))s" "$identChar"
            fi

            if $linebreak; then
                echo "$text"
            else
                echo -n "$text"
            fi
            ;;
    esac
}

