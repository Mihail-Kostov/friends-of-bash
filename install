#!/bin/bash

# ------------
# A install script to install this framework into the /opt directory.
#
# @author    Björn Hempel <bjoern@hempel.li>
# @version   1.0 (2017-05-16)
#
# @copyright MIT License
# @copyright
# @copyright Copyright (c) 2017 Björn Hempel
# @copyright
# @copyright Permission is hereby granted, free of charge, to any person obtaining a copy
# @copyright of this software and associated documentation files (the "Software"), to deal
# @copyright in the Software without restriction, including without limitation the rights
# @copyright to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# @copyright copies of the Software, and to permit persons to whom the Software is
# @copyright furnished to do so, subject to the following conditions:
# @copyright
# @copyright The above copyright notice and this permission notice shall be included in all
# @copyright copies or substantial portions of the Software.
# @copyright
# @copyright THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# @copyright IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# @copyright FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# @copyright AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# @copyright LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# @copyright OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# @copyright SOFTWARE.
# @copyright
# @copyright Written by Björn Hempel <bjoern@hempel.li>.
# ------------

# some user definable constants
TARGET_FOLDER="/opt/friends-of-bash"
EXECUTIVE_FOLDER="/usr/local/bin"

# some user constants
ROOT_UID=0

# some user definable variables
declare -A installableApps
installableApps[install]=""

# some calculable configs before
if [ -h "${BASH_SOURCE[0]}" ]; then
    realScriptname=$(readlink "${BASH_SOURCE[0]}")
    pathRoot=$(dirname "$realScriptname")
    scriptname="${BASH_SOURCE[0]}"
else
    scriptname="$0"
    pathRoot="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
fi

# try to get the git repository source and the name of that repository
if [ -f "$pathRoot/.git/config" ]; then
    gitRepository=$(cat "$pathRoot/.git/config" | grep "url =" | awk '{print $3}')
    [[ "$gitRepository" =~ ([a-zA-Z0-9._-]+)(.git$) ]] && nameRepository="${BASH_REMATCH[1]}" || nameRepository=""
else
    gitRepository=""
    nameRepository=""
fi

# check git repository config
if [ "$gitRepository" == "" ]; then
    echo "No git repository config found → abort.."
    exit 1
fi

# check git name
if [ "$nameRepository" == "" ]; then
    echo "Not able to extract the name of repository → abort.."
    exit 1
fi

# include the complete friends of bash library
source "$pathRoot/lib/all"


# ------------
# install method
#
# @author  Björn Hempel <bjoern@hempel.li>
# @version 1.0 (2017-05-21)
# ------------
install ()
{
    local pathRoot="$1"
    local gitRepository="$2"
    local nameRepository="$3"

    # the global mode needs root credentials
    if [ "$UID" -ne "$ROOT_UID" ]; then
        echo "You need root credentials to install that script into \"$TARGET_FOLDER\"."
        exit 1
    fi

    # get the executive user
    user=$SUDO_USER
    group=$(id -g -n $user)

    # calculate git target paths
    installFolder="$TARGET_FOLDER/$nameRepository"

    # install this project to install folder
    if [ ! -d "$installFolder" ]; then
        # create install folder
        mkdir -p "$installFolder"
        chown $user:$group "$installFolder"
        sudo -u $user git clone "$gitRepository" "$installFolder"

        echo "git repository \"$gitRepository\" successfully installed into \"$installFolder\"."
    else
        echo "The target install folder \"$installFolder\" already exists → skip.."
    fi

    # install the global scripts
    for installableAppSource in "${!installableApps[@]}"; do
        installableAppTarget="${installableApps[$installableAppSource]}"

        sourceScript="$installFolder/$installableAppSource"

        if [ "$installableAppTarget" == "" ]; then
            targetScript="$EXECUTIVE_FOLDER/$nameRepository"
        else
            targetScript="$EXECUTIVE_FOLDER/$nameRepository-$installableAppTarget"
        fi

        # delete true file
        if [ ! -L "$targetScript" ] && [ -f "$targetScript" ]; then
            rm "$targetScript"
        fi

        # delete symlink with wrong target
        if [ -L "$targetScript" ]; then
            targetSymlinkPath=$(readlink -f "$targetScript")

            if [ "$targetSymlinkPath" != "$sourceScript" ]; then
                echo "target from symlink \"$targetSymlinkPath\" is wrong (\"$sourceScript\") → delete this symlink"
                rm "$sourceScript"
            fi
        fi

        # add symlink if the link doesn't exist
        if [ ! -L "$targetScript" ]; then
            echo "create symlink \"$targetScript\"."
            ln -s "$sourceScript" "$targetScript"
        else
            echo "$targetScript already exists → skip.."
        fi
    done
}

# ------------
# update method
#
# @author  Björn Hempel <bjoern@hempel.li>
# @version 1.0 (2017-05-21)
# ------------
update ()
{
    local pathRoot="$1"
    local gitRepository="$2"
    local nameRepository="$3"

    local localHash=$(getCurrentChangesetFromGivenPath "$pathRoot")
    local remoteHash=$(getLastChangesetFromGivenRepository "$gitRepository")

    local localVersion=$(getCurrentTagFromGivenPath "$pathRoot")
    local remoteVersion=$(getLastTagByGivenRepository "$gitRepository")

    # no update is available
    if [ "$localHash" == "$remoteHash" ] && [ "$localVersion" == "$remoteVersion" ]; then
        echo "Your friends of bash version is up to date. Nothing to do here."
        return 0
    fi

    while true; do
        read -n 1 -p "Do you really want to update the current version \"$localVersion\" to \"$remoteVersion\"? Type (y)es or (no): " yn
        case $yn in
            # yes
            [Yy]*)
                break
                ;;
            # no
            [Nn]*)
                echo
                echo "The update was cancelled by user."
                exit
                ;;
            # escape
            $'\e')
                echo
                echo "The update was cancelled by user."
                exit
                ;;
            # other character
            *)
                echo
                ;;
        esac
    done

    echo
    git -C "$pathRoot" pull
}

# ------------
# status method
#
# @author  Björn Hempel <bjoern@hempel.li>
# @version 1.0 (2017-05-21)
# ------------
status ()
{
    local pathRoot="$1"
    local gitRepository="$2"
    local nameRepository="$3"

    local localHash=$(getCurrentChangesetFromGivenPath "$pathRoot")
    local remoteHash=$(getLastChangesetFromGivenRepository "$gitRepository")

    local localVersion=$(getCurrentTagFromGivenPath "$pathRoot")
    local remoteVersion=$(getLastTagByGivenRepository "$gitRepository")

    echo
    echo "$nameRepository"
    echo
    echo "Currently installed version:   $localVersion"
    echo "Available version:             $remoteVersion"
    echo
    echo "Currently installed changeset: $localHash"
    echo "Available changeset:           $remoteHash"
    echo

    if [ "$localHash" == "$remoteHash" ] && [ "$localVersion" == "$remoteVersion" ]; then
        echo "Your friends of bash version is up to date. Nothing to do here."
        echo
    else
        echo "Your friends of bash library version is not up to date. Please update with:"
        echo "user\$ $0 --update"
        echo
    fi
}

# ------------
# Shows the version number of this library.
#
# @author  Björn Hempel <bjoern@hempel.li>
# @version 1.0 (2017-05-21)
# ------------
showVersion ()
{
    local localHash=$(getCurrentChangesetFromGivenPath "$pathRoot")
    local localVersion=$(getCurrentTagFromGivenPath "$pathRoot")

    echo "$nameRepository/$localVersion ($localHash)"
}

# check the current target path
executionPathIsTarget=false
if [[ "$pathRoot" =~ "$TARGET_FOLDER" ]]; then
    executionPathIsTarget=true
fi

source "$pathRoot/parameter"

# execute function according the execution type
case $executionType in
    install)
        install "$pathRoot" "$gitRepository" "$nameRepository"
        ;;

    status)
        status "$pathRoot" "$gitRepository" "$nameRepository"
        ;;

    update)
        update "$pathRoot" "$gitRepository" "$nameRepository"
        ;;

    # other character
    *)
        echo 'unknown execution type'
        ;;

esac


